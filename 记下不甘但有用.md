[toc]

# 写在前面

名字来源于日剧 "逃避可耻但有用" （" 逃げるは恥だが役に立つ "）。

我原来是不想专门把平常看到的不熟悉的 java 知识给记在一个单独的类似笔记本的地方的，因为我太弱了，不熟悉的地方是在是太多了，一个一个都记下来得多累。

但是今晚（20191218）想想还是得有这么个东西：一来是自己写笔记的过程也相当于是个梳理的过程，能加深对不熟悉部分的理解程度；二来是方便以后的复习。

有些人看过的东西能永远记住，可惜的是我不是那类人，还是有些不甘心的。所以就将这份笔记的名称暂且设置为 “心有不甘但有用”。

# 正文

## 其它笔记（未分类）

## Iterator

jdk 源码上面都写着，非常详细。

### 光标位置 cursor position

Iterator 的光标是在**内部两个元素的之间**，如果还没有执行 `next()` 方法就在首元素前面，如果所有元素都遍历完后就在末尾元素之后。

图示：

```java
// 假设链表为 ABC
// | 为光标
// 开始 |ABC
// next() A|BC
// next() AB|C
// next() ABC|
```

`remove()` 删除上个 `next()` 返回的元素，如果还未调用 `next()`, 将会抛出 `IlleagalStateException` 。这部分接下来会讲得更多一些。

## ListIterator

接口，继承了 Iterator 接口。**ListIterator 是有序的，因此有涉及索引，在特定位置添加新元素等方法。**

### add(E)

与 `Collection.add(E)` 不同，其不返回 boolean 类型的值，它假定添加操作总是会改变链表。

**`ListIterator.add(E)` 会在光标之前添加一个新的元素。** （不要搞混）

```java
List<String> staff = new LinkedList<>();
ListIterator<String> iter = staff.ListIterator();

iter.add("chen"); // "chen" |
iter.add("lele"); // "chen" "lele" |

//报错 NoSuchElementException, 因为光标之后没有元素了
System.out.println(iter.next()) 
```

### remove()

与 `Iterator.remove()` 必须在 `next()` 方法调用后使用不同，ListIterator 既有 `previous()` 方法又有 `next()` 方法，所以可以跟在这两个方法的任何一个后面，结果也如此：如果跟在 `previous()`之后，就会删除之前 `previous()` 所返回的元素。

### add 只依赖光标的位置，而 remove 和 set 依赖迭代器的状态

解释后半部分，直接看相关 jdk 源码会更容易说明一些, 解释。

**以 `LinkedList` 源码中的 `ListItr` 内部类为例，他有个内部成员变量 `lastReturned`,  专门用来记录 `next()` 或是 `previous()`  方法返回的值。 如果其值为 `null` 那么将会抛出 `IlleagalStateException` 错误。并且在最后会把 `lastReturned` 重新设置为 `null`（仅 remove 方法会这样做，set 方法不会将其重新设置为 `null`）。add 方法也会将其设置为 `null`**

明白了以上这一段，基本就能搞清楚 ListIterator 一系列的操作了。



